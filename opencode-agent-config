#!/usr/bin/env node

/**
 * Oh My Opencode Agent Configuration Tool
 * Interactive CLI for managing agent model assignments
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync } = require('child_process');

// Configuration paths
const CONFIG_DIR = path.join(process.env.HOME, '.config', 'opencode');
const CONFIG_FILE = path.join(CONFIG_DIR, 'oh-my-opencode.json');
const BACKUP_DIR = path.join(CONFIG_DIR, 'backups');
const CONFIGS_DIR = path.join(CONFIG_DIR, 'configs');
const ACTIVE_CONFIG_FILE = path.join(CONFIG_DIR, 'active-config.json');

// Default agent configurations
const DEFAULTS = {
  "google_auth": false,
  "agents": {
    "oracle": {
      "model": "opencode/gpt-5.2"
    },
    "Sisyphus": {
      "model": "google/claude-opus-4-5-thinking"
    },
    "librarian": {
      "model": "google/claude-sonnet-4-5"
    },
    "frontend-ui-ux-engineer": {
      "model": "google/gemini-3-pro-high"
    },
    "document-writer": {
      "model": "google/gemini-3-flash"
    },
    "multimodal-looker": {
      "model": "google/gemini-3-flash"
    }
  },
  "mcps": {
    "websearch_exa": {
      "url": "https://mcp.exa.ai/mcp?exaApiKey=4bfbfbd6-a907-4f05-98ca-cf6206af4eba&tools=web_search_exa,get_code_context_exa,crawling_exa,company_research_exa,linkedin_search_exa,deep_researcher_start,deep_researcher_check",
      "type": "remote",
      "enabled": true
    },
    "grep_app": {
      "url": "https://mcp.grep.app",
      "type": "remote"
    }
  }
};

// Configuration Manager
class ConfigurationManager {
  constructor() {
    this.ensureDirectories();
  }

  ensureDirectories() {
    if (!fs.existsSync(CONFIGS_DIR)) {
      fs.mkdirSync(CONFIGS_DIR, { recursive: true });
    }
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }
  }

  validateConfigName(name) {
    if (!name || typeof name !== 'string') return false;
    // Allow alphanumeric, hyphens, underscores
    return /^[a-z0-9-_]+$/i.test(name);
  }

  getConfigPath(name) {
    return path.join(CONFIGS_DIR, `${name}.json`);
  }

  listConfigurations() {
    try {
      const files = fs.readdirSync(CONFIGS_DIR)
        .filter(f => f.endsWith('.json'))
        .map(f => f.replace('.json', ''));
      return files;
    } catch (error) {
      return [];
    }
  }

  configExists(name) {
    return fs.existsSync(this.getConfigPath(name));
  }

  loadConfiguration(name) {
    const configPath = this.getConfigPath(name);
    try {
      const data = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      throw new Error(`Failed to load configuration "${name}": ${error.message}`);
    }
  }

  saveConfiguration(name, description, config) {
    if (!this.validateConfigName(name)) {
      throw new Error('Invalid configuration name. Use only letters, numbers, hyphens, and underscores.');
    }

    const configPath = this.getConfigPath(name);
    const now = new Date().toISOString();
    
    let metadata = {
      name,
      description,
      created: now,
      modified: now,
      config
    };

    // Preserve creation timestamp if config exists
    if (fs.existsSync(configPath)) {
      try {
        const existing = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        if (existing.created) {
          metadata.created = existing.created;
        }
      } catch (e) {
        // Ignore, will use new timestamp
      }
    }

    fs.writeFileSync(configPath, JSON.stringify(metadata, null, 2));
    return metadata;
  }

  deleteConfiguration(name) {
    const configPath = this.getConfigPath(name);
    if (!fs.existsSync(configPath)) {
      throw new Error(`Configuration "${name}" does not exist`);
    }
    fs.unlinkSync(configPath);
  }

  renameConfiguration(oldName, newName) {
    if (!this.validateConfigName(newName)) {
      throw new Error('Invalid configuration name. Use only letters, numbers, hyphens, and underscores.');
    }

    const oldPath = this.getConfigPath(oldName);
    const newPath = this.getConfigPath(newName);

    if (!fs.existsSync(oldPath)) {
      throw new Error(`Configuration "${oldName}" does not exist`);
    }

    if (fs.existsSync(newPath)) {
      throw new Error(`Configuration "${newName}" already exists`);
    }

    // Update name in metadata
    const metadata = JSON.parse(fs.readFileSync(oldPath, 'utf8'));
    metadata.name = newName;
    metadata.modified = new Date().toISOString();
    
    fs.writeFileSync(newPath, JSON.stringify(metadata, null, 2));
    fs.unlinkSync(oldPath);
  }

  getActiveConfig() {
    try {
      if (fs.existsSync(ACTIVE_CONFIG_FILE)) {
        const data = JSON.parse(fs.readFileSync(ACTIVE_CONFIG_FILE, 'utf8'));
        return data.active;
      }
    } catch (error) {
      // Fall through to default
    }
    return null;
  }

  setActiveConfig(name) {
    fs.writeFileSync(ACTIVE_CONFIG_FILE, JSON.stringify({ active: name }, null, 2));
  }

  updateMainConfigFile(config) {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
  }

  migrateIfNeeded() {
    this.ensureDirectories();
    
    // Check if migration already done
    if (this.listConfigurations().length > 0) {
      return false;
    }

    console.log('\nFirst-time setup: migrating to configuration profiles...\n');

    // Create omo-default from DEFAULTS
    this.saveConfiguration('omo-default', 'Oh My Opencode default configuration', DEFAULTS);

    // Migrate existing config if it exists
    if (fs.existsSync(CONFIG_FILE)) {
      try {
        const existing = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
        this.saveConfiguration('user-config', 'Migrated user configuration', existing);
        this.setActiveConfig('user-config');
        console.log('✓ Migrated existing configuration to "user-config"');
      } catch (error) {
        console.error('Warning: Could not migrate existing config, using defaults');
        this.setActiveConfig('omo-default');
      }
    } else {
      this.setActiveConfig('omo-default');
    }

    console.log('✓ Created "omo-default" configuration');
    console.log('✓ Migration complete\n');
    return true;
  }

  exportConfiguration(name, destPath) {
    const metadata = this.loadConfiguration(name);
    fs.writeFileSync(destPath, JSON.stringify(metadata, null, 2));
  }

  importConfiguration(sourcePath, name, description) {
    const data = JSON.parse(fs.readFileSync(sourcePath, 'utf8'));
    
    // Handle both wrapped and unwrapped formats
    const config = data.config || data;
    const desc = description || data.description || 'Imported configuration';
    
    this.saveConfiguration(name, desc, config);
  }
}

// Agent characteristics for recommendations
const AGENT_PROFILES = {
  "oracle": {
    description: "Strategic reasoning and complex problem solving",
    preferred: ["reasoning", "large_context"],
    minContext: 128000
  },
  "Sisyphus": {
    description: "Extended thinking for complex multi-step tasks",
    preferred: ["reasoning", "thinking", "large_context"],
    minContext: 128000
  },
  "librarian": {
    description: "Research, knowledge retrieval, and comprehension",
    preferred: ["large_context", "fast"],
    minContext: 128000
  },
  "frontend-ui-ux-engineer": {
    description: "UI/UX work with visual understanding",
    preferred: ["multimodal", "image_input"],
    minContext: 64000
  },
  "document-writer": {
    description: "Fast, efficient text generation and documentation",
    preferred: ["fast", "text_output"],
    minContext: 32000
  },
  "multimodal-looker": {
    description: "Visual analysis and image/PDF understanding",
    preferred: ["multimodal", "image_input", "pdf_input"],
    minContext: 32000
  }
};

class AgentConfigTool {
  constructor() {
    this.config = null;
    this.configName = null;
    this.configMetadata = null;
    this.models = null;
    this.providers = [];
    this.configManager = new ConfigurationManager();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  async loadConfig() {
    try {
      // Run migration if needed
      this.configManager.migrateIfNeeded();

      // Get active config name
      this.configName = this.configManager.getActiveConfig();
      if (!this.configName) {
        this.configName = 'omo-default';
        this.configManager.setActiveConfig(this.configName);
      }

      // Load configuration metadata
      this.configMetadata = this.configManager.loadConfiguration(this.configName);
      this.config = this.configMetadata.config;

      // Update main config file to match active config
      this.configManager.updateMainConfigFile(this.config);
    } catch (error) {
      console.error(`Error loading config: ${error.message}`);
      process.exit(1);
    }
  }

  async loadModels() {
    try {
      console.log('Loading available models...');
      const output = execSync('opencode models --verbose 2>/dev/null', { encoding: 'utf8' });
      this.models = this.parseModels(output);
      this.extractProviders();
      console.log(`Loaded ${this.models.length} models from ${this.providers.length} providers\n`);
    } catch (error) {
      console.error(`Error loading models: ${error.message}`);
      process.exit(1);
    }
  }

  parseModels(output) {
    const models = [];
    const lines = output.split('\n');
    let currentModel = null;
    let jsonBuffer = '';
    let braceCount = 0;

    for (const line of lines) {
      if (line.match(/^[a-z0-9-]+\/[a-z0-9-.:/]+$/i) && braceCount === 0) {
        currentModel = line.trim();
        jsonBuffer = '';
      } else if (currentModel) {
        // Count braces to handle nested objects
        const openBraces = (line.match(/{/g) || []).length;
        const closeBraces = (line.match(/}/g) || []).length;
        braceCount += openBraces - closeBraces;
        
        jsonBuffer += (jsonBuffer ? '\n' : '') + line;
        
        if (braceCount === 0 && jsonBuffer) {
          try {
            const modelData = JSON.parse(jsonBuffer);
            models.push({
              id: currentModel,
              ...modelData
            });
          } catch (e) {
            // Skip malformed JSON
          }
          currentModel = null;
          jsonBuffer = '';
        }
      }
    }

    return models;
  }

  extractProviders() {
    const providerSet = new Set();
    this.models.forEach(model => {
      // Use providerID from model data, fall back to splitting ID if not present
      const provider = model.providerID || model.id.split('/')[0];
      if (provider) {
        providerSet.add(provider);
      }
    });
    this.providers = Array.from(providerSet).sort();
  }

  scoreModel(model, agentType) {
    const profile = AGENT_PROFILES[agentType];
    if (!profile) return 0;

    let score = 0;

    // Context window check
    if (model.limit?.context >= profile.minContext) {
      score += 10;
    }

    // Capability scoring
    const caps = model.capabilities || {};
    
    for (const pref of profile.preferred) {
      switch (pref) {
        case "reasoning":
          if (caps.reasoning) score += 15;
          break;
        case "thinking":
          if (model.name?.toLowerCase().includes('thinking') || 
              model.id?.toLowerCase().includes('thinking')) score += 10;
          break;
        case "large_context":
          if (model.limit?.context >= 200000) score += 8;
          break;
        case "multimodal":
          if (caps.input?.image || caps.input?.pdf) score += 15;
          break;
        case "image_input":
          if (caps.input?.image) score += 12;
          break;
        case "pdf_input":
          if (caps.input?.pdf) score += 8;
          break;
        case "fast":
          if (model.name?.toLowerCase().includes('flash') || 
              model.name?.toLowerCase().includes('fast')) score += 8;
          break;
        case "text_output":
          if (caps.output?.text) score += 5;
          break;
      }
    }

    // Preferred provider bonus
    const preferredProviders = this.config?.preferred_providers || [];
    if (preferredProviders.length > 0) {
      const provider = model.providerID || model.id.split('/')[0];
      const providerIndex = preferredProviders.indexOf(provider);
      if (providerIndex !== -1) {
        // Higher bonus for providers earlier in the preference list
        score += (preferredProviders.length - providerIndex) * 5;
      }
    }

    return score;
  }

  getRecommendedModels(agentType, limit = 5) {
    const scored = this.models.map(model => ({
      ...model,
      score: this.scoreModel(model, agentType)
    }));

    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, limit);
  }

  createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupFile = path.join(BACKUP_DIR, `${this.configName}-${timestamp}.json`);
    
    try {
      const configPath = this.configManager.getConfigPath(this.configName);
      if (fs.existsSync(configPath)) {
        fs.copyFileSync(configPath, backupFile);
        console.log(`✓ Backup created: ${backupFile}\n`);
      }
      return backupFile;
    } catch (error) {
      console.error(`Error creating backup: ${error.message}`);
      throw error;
    }
  }

  saveConfig() {
    try {
      this.createBackup();
      
      // Update metadata modified timestamp and save
      const description = this.configMetadata?.description || 'Configuration';
      this.configMetadata = this.configManager.saveConfiguration(
        this.configName,
        description,
        this.config
      );
      
      // Update main config file
      this.configManager.updateMainConfigFile(this.config);
      
      console.log('✓ Configuration saved successfully\n');
    } catch (error) {
      console.error(`Error saving config: ${error.message}`);
      throw error;
    }
  }

  async restoreDefaults() {
    try {
      // Switch to omo-default configuration
      await this.switchToConfiguration('omo-default');
      console.log('✓ Switched to default configuration\n');
    } catch (error) {
      console.error(`Error restoring defaults: ${error.message}`);
    }
  }

  formatModel(model) {
    const ctx = model.limit?.context ? `${Math.floor(model.limit.context / 1000)}K` : '?';
    const caps = [];
    
    if (model.capabilities?.reasoning) caps.push('R');
    if (model.capabilities?.input?.image) caps.push('I');
    if (model.capabilities?.input?.pdf) caps.push('P');
    
    const capsStr = caps.length > 0 ? `[${caps.join('')}]` : '';
    return `${model.name || model.id} (${ctx}${capsStr})`;
  }

  async prompt(question) {
    return new Promise(resolve => {
      this.rl.question(question, answer => resolve(answer.trim()));
    });
  }

  async selectModel(agentType, currentModel) {
    console.clear();
    const profile = AGENT_PROFILES[agentType];
    
    console.log(`\n${'='.repeat(70)}`);
    console.log(`Select Model for: ${agentType}`);
    console.log(`Description: ${profile?.description || 'Custom agent'}`);
    console.log(`Current: ${currentModel}`);
    console.log(`${'='.repeat(70)}\n`);

    const recommended = this.getRecommendedModels(agentType, 8);
    
    console.log('RECOMMENDED MODELS:\n');
    recommended.forEach((model, idx) => {
      const current = model.id === currentModel ? ' ⭐ (current)' : '';
      console.log(`  ${idx + 1}. ${this.formatModel(model)}${current}`);
    });

    console.log('\n[S] Search all models');
    console.log('[F] Filter by provider');
    console.log('[C] Cancel\n');

    const choice = await this.prompt('Select option: ');

    if (choice.toLowerCase() === 'c') {
      return null;
    }

    if (choice.toLowerCase() === 's') {
      return await this.searchModels(agentType, currentModel);
    }

    if (choice.toLowerCase() === 'f') {
      return await this.filterByProvider(agentType, currentModel);
    }

    const idx = parseInt(choice) - 1;
    if (idx >= 0 && idx < recommended.length) {
      return recommended[idx].id;
    }

    console.log('Invalid choice');
    await this.prompt('Press Enter to continue...');
    return await this.selectModel(agentType, currentModel);
  }

  async searchModels(agentType, currentModel) {
    console.clear();
    console.log('\n--- Search Models ---\n');
    
    const query = await this.prompt('Search (provider/name or Enter for all): ');
    const filtered = query 
      ? this.models.filter(m => m.id.toLowerCase().includes(query.toLowerCase()) || 
                                 m.name?.toLowerCase().includes(query.toLowerCase()))
      : this.models;

    if (filtered.length === 0) {
      console.log('No models found');
      await this.prompt('Press Enter to continue...');
      return await this.selectModel(agentType, currentModel);
    }

    return await this.displayModelList(filtered, agentType, currentModel);
  }

  async filterByProvider(agentType, currentModel) {
    console.clear();
    console.log('\n--- Filter by Provider ---\n');
    
    console.log('AVAILABLE PROVIDERS:\n');
    this.providers.forEach((provider, idx) => {
      const count = this.models.filter(m => (m.providerID || m.id.split('/')[0]) === provider).length;
      console.log(`  ${idx + 1}. ${provider} (${count} models)`);
    });

    console.log('\n[A] Select All');
    console.log('[C] Cancel\n');
    
    const choice = await this.prompt('Select providers (comma-separated numbers or letters): ');
    
    if (choice.toLowerCase() === 'c') {
      return await this.selectModel(agentType, currentModel);
    }

    let selectedProviders = [];
    if (choice.toLowerCase() === 'a') {
      selectedProviders = this.providers;
    } else {
      const indices = choice.split(',').map(s => parseInt(s.trim()) - 1);
      selectedProviders = indices
        .filter(idx => idx >= 0 && idx < this.providers.length)
        .map(idx => this.providers[idx]);
    }

    if (selectedProviders.length === 0) {
      console.log('No providers selected');
      await this.prompt('Press Enter to continue...');
      return await this.filterByProvider(agentType, currentModel);
    }

    const filtered = this.models.filter(m => {
      const provider = m.providerID || m.id.split('/')[0];
      return selectedProviders.includes(provider);
    });

    return await this.displayModelList(filtered, agentType, currentModel);
  }

  async displayModelList(filtered, agentType, currentModel) {
    const perPage = 15;
    let page = 0;

    while (true) {
      console.clear();
      console.log(`\n--- Models (${filtered.length} total) - Page ${page + 1}/${Math.ceil(filtered.length / perPage)} ---\n`);

      const start = page * perPage;
      const end = Math.min(start + perPage, filtered.length);

      for (let i = start; i < end; i++) {
        const current = filtered[i].id === currentModel ? ' ⭐' : '';
        console.log(`  ${i + 1}. ${this.formatModel(filtered[i])}${current}`);
      }

      console.log('\n[N] Next page  [P] Previous page  [#] Select number  [C] Cancel\n');
      const choice = await this.prompt('Select option: ');

      if (choice.toLowerCase() === 'c') {
        return await this.selectModel(agentType, currentModel);
      }
      if (choice.toLowerCase() === 'n' && end < filtered.length) {
        page++;
        continue;
      }
      if (choice.toLowerCase() === 'p' && page > 0) {
        page--;
        continue;
      }

      const idx = parseInt(choice) - 1;
      if (idx >= 0 && idx < filtered.length) {
        return filtered[idx].id;
      }
    }
  }

  async editAgent(agentName) {
    const currentModel = this.config.agents[agentName]?.model || 'none';
    const newModel = await this.selectModel(agentName, currentModel);

    if (newModel && newModel !== currentModel) {
      if (!this.config.agents[agentName]) {
        this.config.agents[agentName] = {};
      }
      this.config.agents[agentName].model = newModel;
      this.saveConfig();
      console.log(`✓ Updated ${agentName} to ${newModel}`);
      await this.prompt('Press Enter to continue...');
    }
  }

  async addAgent() {
    console.clear();
    console.log('\n--- Add New Agent ---\n');
    
    const name = await this.prompt('Agent name: ');
    if (!name) return;

    if (this.config.agents[name]) {
      console.log('Agent already exists');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const model = await this.selectModel(name, null);
    if (model) {
      this.config.agents[name] = { model };
      this.saveConfig();
      console.log(`✓ Added agent ${name} with model ${model}`);
      await this.prompt('Press Enter to continue...');
    }
  }

  async deleteAgent(agentName) {
    const confirm = await this.prompt(`Delete agent "${agentName}"? (yes/no): `);
    if (confirm.toLowerCase() === 'yes') {
      delete this.config.agents[agentName];
      this.saveConfig();
      console.log(`✓ Deleted agent ${agentName}`);
      await this.prompt('Press Enter to continue...');
    }
  }

  async switchToConfiguration(configName) {
    if (!this.configManager.configExists(configName)) {
      throw new Error(`Configuration "${configName}" does not exist`);
    }

    this.configName = configName;
    this.configManager.setActiveConfig(configName);
    this.configMetadata = this.configManager.loadConfiguration(configName);
    this.config = this.configMetadata.config;
    this.configManager.updateMainConfigFile(this.config);
  }

  async manageConfigurationsMenu() {
    while (true) {
      console.clear();
      console.log('\n' + '='.repeat(70));
      console.log('Manage Configurations');
      console.log('='.repeat(70) + '\n');

      const configs = this.configManager.listConfigurations();
      
      console.log('AVAILABLE CONFIGURATIONS:\n');
      configs.forEach((name, idx) => {
        const active = name === this.configName ? ' [ACTIVE]' : '';
        const metadata = this.configManager.loadConfiguration(name);
        const modDate = new Date(metadata.modified).toLocaleDateString();
        console.log(`  ${idx + 1}. ${name}${active}`);
        console.log(`     ${metadata.description}`);
        console.log(`     Modified: ${modDate}\n`);
      });

      console.log('ACTIONS:\n');
      console.log('  [S] Switch active configuration');
      console.log('  [C] Create new configuration');
      console.log('  [R] Rename configuration');
      console.log('  [D] Delete configuration');
      console.log('  [E] Export configuration');
      console.log('  [I] Import configuration');
      console.log('  [X] Return to main menu\n');

      const choice = await this.prompt('Select option: ');

      switch (choice.toLowerCase()) {
        case 's':
          await this.switchConfiguration();
          break;
        case 'c':
          await this.createConfiguration();
          break;
        case 'r':
          await this.renameConfiguration();
          break;
        case 'd':
          await this.deleteConfiguration();
          break;
        case 'e':
          await this.exportConfiguration();
          break;
        case 'i':
          await this.importConfiguration();
          break;
        case 'x':
          return;
        default:
          console.log('Invalid option');
          await this.prompt('Press Enter to continue...');
      }
    }
  }

  async switchConfiguration() {
    console.clear();
    console.log('\n--- Switch Configuration ---\n');
    
    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      const active = name === this.configName ? ' [ACTIVE]' : '';
      console.log(`  ${idx + 1}. ${name}${active}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice) - 1;
    if (idx >= 0 && idx < configs.length) {
      const configName = configs[idx];
      if (configName === this.configName) {
        console.log('Already active');
      } else {
        try {
          await this.switchToConfiguration(configName);
          console.log(`\n✓ Switched to configuration: ${configName}`);
        } catch (error) {
          console.error(`Error: ${error.message}`);
        }
      }
    } else {
      console.log('Invalid selection');
    }

    await this.prompt('Press Enter to continue...');
  }

  async createConfiguration() {
    console.clear();
    console.log('\n--- Create New Configuration ---\n');

    const name = await this.prompt('Configuration name: ');
    if (!name) return;

    if (this.configManager.configExists(name)) {
      console.log('Configuration already exists');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const description = await this.prompt('Description: ');
    
    console.log('\nCreate from:\n');
    console.log('  [1] Copy omo-default (recommended - start with OmO agents)');
    console.log('  [2] Copy from another configuration');
    console.log('  [3] Copy current configuration');
    console.log('  [4] Minimal configuration (no agents)\n');

    const choice = await this.prompt('Select option: ');
    
    let config;
    let needsSetup = false;
    let copiedFrom = null;
    
    switch (choice) {
      case '1':
        const defaultMeta = this.configManager.loadConfiguration('omo-default');
        config = JSON.parse(JSON.stringify(defaultMeta.config));
        copiedFrom = 'omo-default';
        break;
      case '2': {
        // Show list of configurations to copy from
        console.clear();
        console.log('\n--- Select Configuration to Copy ---\n');
        
        const configs = this.configManager.listConfigurations();
        configs.forEach((configName, idx) => {
          const metadata = this.configManager.loadConfiguration(configName);
          const current = configName === this.configName ? ' [CURRENT]' : '';
          console.log(`  ${idx + 1}. ${configName}${current}`);
          console.log(`     ${metadata.description}\n`);
        });
        
        console.log('[C] Cancel\n');
        const copyChoice = await this.prompt('Select configuration: ');
        
        if (copyChoice.toLowerCase() === 'c') return;
        
        const copyIdx = parseInt(copyChoice) - 1;
        if (copyIdx < 0 || copyIdx >= configs.length) {
          console.log('Invalid selection');
          await this.prompt('Press Enter to continue...');
          return;
        }
        
        const sourceConfig = configs[copyIdx];
        const sourceMeta = this.configManager.loadConfiguration(sourceConfig);
        config = JSON.parse(JSON.stringify(sourceMeta.config));
        copiedFrom = sourceConfig;
        break;
      }
      case '3':
        config = JSON.parse(JSON.stringify(this.config));
        copiedFrom = this.configName;
        break;
      case '4':
        config = { google_auth: false, agents: {}, mcps: {} };
        needsSetup = true;
        break;
      default:
        console.log('Invalid option');
        await this.prompt('Press Enter to continue...');
        return;
    }

    try {
      this.configManager.saveConfiguration(name, description || 'New configuration', config);
      console.log(`\n✓ Created configuration: ${name}`);
      
      if (copiedFrom) {
        console.log(`  Copied from: ${copiedFrom}`);
      }
      
      if (needsSetup) {
        console.log('\nNote: This configuration has no agents.');
        console.log('Oh My Opencode expects agents to be configured.');
        console.log('You should add agents before using this configuration.');
      }
      
      const switchNow = await this.prompt('\nSwitch to this configuration now? (yes/no): ');
      if (switchNow.toLowerCase() === 'yes') {
        await this.switchToConfiguration(name);
        console.log(`✓ Switched to: ${name}`);
        
        if (needsSetup) {
          console.log('\nTip: Use [A] Add new agent to configure agents for OmO.');
        } else if (choice === '1' || choice === '2') {
          console.log('\nTip: Use [E] Edit agent model to customize agent models.');
        }
      }
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('\nPress Enter to continue...');
  }

  async renameConfiguration() {
    console.clear();
    console.log('\n--- Rename Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      console.log(`  ${idx + 1}. ${name}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to rename: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice) - 1;
    if (idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const oldName = configs[idx];
    const newName = await this.prompt('New name: ');

    if (!newName) return;

    try {
      this.configManager.renameConfiguration(oldName, newName);
      
      // Update active config if we renamed the active one
      if (oldName === this.configName) {
        this.configName = newName;
        this.configManager.setActiveConfig(newName);
      }
      
      console.log(`\n✓ Renamed "${oldName}" to "${newName}"`);
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async deleteConfiguration() {
    console.clear();
    console.log('\n--- Delete Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    
    if (configs.length === 1) {
      console.log('Cannot delete the last configuration');
      await this.prompt('Press Enter to continue...');
      return;
    }

    configs.forEach((name, idx) => {
      const active = name === this.configName ? ' [ACTIVE - cannot delete]' : '';
      console.log(`  ${idx + 1}. ${name}${active}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to delete: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice) - 1;
    if (idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const configName = configs[idx];
    
    if (configName === this.configName) {
      console.log('Cannot delete active configuration. Switch to another first.');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const confirm = await this.prompt(`Delete "${configName}"? This cannot be undone. (yes/no): `);
    if (confirm.toLowerCase() === 'yes') {
      try {
        this.configManager.deleteConfiguration(configName);
        console.log(`\n✓ Deleted configuration: ${configName}`);
      } catch (error) {
        console.error(`Error: ${error.message}`);
      }
    }

    await this.prompt('Press Enter to continue...');
  }

  async exportConfiguration() {
    console.clear();
    console.log('\n--- Export Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      console.log(`  ${idx + 1}. ${name}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to export: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice) - 1;
    if (idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const configName = configs[idx];
    const destPath = await this.prompt('Destination path (e.g., ~/my-config.json): ');

    if (!destPath) return;

    try {
      const expandedPath = destPath.replace(/^~/, process.env.HOME);
      this.configManager.exportConfiguration(configName, expandedPath);
      console.log(`\n✓ Exported "${configName}" to ${expandedPath}`);
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async importConfiguration() {
    console.clear();
    console.log('\n--- Import Configuration ---\n');

    const sourcePath = await this.prompt('Source path (e.g., ~/my-config.json): ');
    if (!sourcePath) return;

    const name = await this.prompt('Configuration name: ');
    if (!name) return;

    if (this.configManager.configExists(name)) {
      console.log('Configuration with this name already exists');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const description = await this.prompt('Description (optional): ');

    try {
      const expandedPath = sourcePath.replace(/^~/, process.env.HOME);
      this.configManager.importConfiguration(expandedPath, name, description);
      console.log(`\n✓ Imported configuration as "${name}"`);
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async setPreferredProviders() {
    console.clear();
    console.log('\n--- Set Preferred Providers ---\n');
    
    const currentPreferred = this.config.preferred_providers || [];
    
    if (currentPreferred.length > 0) {
      console.log('CURRENT PREFERRED PROVIDERS:\n');
      currentPreferred.forEach((provider, idx) => {
        console.log(`  ${idx + 1}. ${provider}`);
      });
      console.log('');
    }
    
    console.log('AVAILABLE PROVIDERS:\n');
    this.providers.forEach((provider, idx) => {
      const count = this.models.filter(m => (m.providerID || m.id.split('/')[0]) === provider).length;
      const preferred = currentPreferred.includes(provider) ? ' (preferred)' : '';
      console.log(`  ${idx + 1}. ${provider} (${count} models)${preferred}`);
    });

    console.log('\n[C] Clear preferences');
    console.log('[X] Cancel\n');
    
    const choice = await this.prompt('Select providers (comma-separated numbers) or action: ');
    
    if (choice.toLowerCase() === 'x') {
      return;
    }

    if (choice.toLowerCase() === 'c') {
      delete this.config.preferred_providers;
      this.saveConfig();
      console.log('✓ Cleared preferred providers');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const indices = choice.split(',').map(s => parseInt(s.trim()) - 1);
    const selectedProviders = indices
      .filter(idx => idx >= 0 && idx < this.providers.length)
      .map(idx => this.providers[idx]);

    if (selectedProviders.length === 0) {
      console.log('No providers selected');
      await this.prompt('Press Enter to continue...');
      return;
    }

    this.config.preferred_providers = selectedProviders;
    this.saveConfig();
    console.log(`✓ Set preferred providers: ${selectedProviders.join(', ')}`);
    await this.prompt('Press Enter to continue...');
  }

  async mainMenu() {
    while (true) {
      console.clear();
      console.log('\n' + '='.repeat(70));
      console.log('Oh My Opencode - Agent Configuration');
      console.log('='.repeat(70));
      
      // Show active configuration
      const modDate = new Date(this.configMetadata.modified).toLocaleDateString();
      console.log(`\nActive Configuration: ${this.configName}`);
      console.log(`Description: ${this.configMetadata.description}`);
      console.log(`Modified: ${modDate}\n`);

      console.log('CURRENT AGENTS:\n');
      const agents = Object.entries(this.config.agents || {});
      
      if (agents.length === 0) {
        console.log('  No agents configured\n');
      } else {
        agents.forEach(([name, config], idx) => {
          console.log(`  ${idx + 1}. ${name.padEnd(30)} → ${config.model}`);
        });
      }

      console.log('\nACTIONS:\n');
      console.log('  [E] Edit agent model');
      console.log('  [A] Add new agent');
      console.log('  [D] Delete agent');
      console.log('  [P] Set preferred providers');
      console.log('  [M] Manage configurations');
      console.log('  [R] Restore defaults');
      console.log('  [B] View backups');
      console.log('  [Q] Quit\n');

      const choice = await this.prompt('Select option: ');

      switch (choice.toLowerCase()) {
        case 'e': {
          const agent = await this.prompt('Agent name: ');
          if (this.config.agents[agent]) {
            await this.editAgent(agent);
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'a':
          await this.addAgent();
          break;
        case 'd': {
          const agent = await this.prompt('Agent name: ');
          if (this.config.agents[agent]) {
            await this.deleteAgent(agent);
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'p':
          await this.setPreferredProviders();
          break;
        case 'm':
          await this.manageConfigurationsMenu();
          break;
        case 'r': {
          const confirm = await this.prompt('Restore all agents to defaults? (yes/no): ');
          if (confirm.toLowerCase() === 'yes') {
            await this.restoreDefaults();
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'b':
          await this.viewBackups();
          break;
        case 'q':
          this.rl.close();
          console.log('\nGoodbye!\n');
          return;
        default:
          console.log('Invalid option');
          await this.prompt('Press Enter to continue...');
      }
    }
  }

  async viewBackups() {
    console.clear();
    console.log('\n--- Configuration Backups ---\n');
    
    try {
      const allFiles = fs.readdirSync(BACKUP_DIR)
        .filter(f => f.endsWith('.json'))
        .sort()
        .reverse();
      
      // Filter for current config
      const currentConfigFiles = allFiles.filter(f => f.startsWith(`${this.configName}-`));
      
      console.log(`Backups for "${this.configName}":\n`);
      if (currentConfigFiles.length === 0) {
        console.log('  No backups found for this configuration');
      } else {
        currentConfigFiles.slice(0, 10).forEach((file, idx) => {
          const stats = fs.statSync(path.join(BACKUP_DIR, file));
          console.log(`  ${idx + 1}. ${file} (${stats.size} bytes)`);
        });
      }
      
      // Show option to view all backups
      const otherFiles = allFiles.filter(f => !f.startsWith(`${this.configName}-`));
      if (otherFiles.length > 0) {
        console.log(`\nOther configurations have ${otherFiles.length} backup(s)`);
        const showAll = await this.prompt('Show all backups? (yes/no): ');
        
        if (showAll.toLowerCase() === 'yes') {
          console.clear();
          console.log('\n--- All Configuration Backups ---\n');
          allFiles.slice(0, 20).forEach((file, idx) => {
            const stats = fs.statSync(path.join(BACKUP_DIR, file));
            console.log(`  ${idx + 1}. ${file} (${stats.size} bytes)`);
          });
        }
      }
    } catch (error) {
      console.log(`Error reading backups: ${error.message}`);
    }

    await this.prompt('\nPress Enter to continue...');
  }

  async run() {
    console.log('\nOh My Opencode Agent Configuration Tool\n');
    
    await this.loadConfig();
    await this.loadModels();
    await this.mainMenu();
  }
}

// Run the tool
const tool = new AgentConfigTool();
tool.run().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
